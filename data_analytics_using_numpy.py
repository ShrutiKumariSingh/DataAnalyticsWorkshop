# -*- coding: utf-8 -*-
"""Data Analytics Using Numpy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NXawHYz5p_EvDkCrEAPU-rFL-PnzA0bI
"""

import numpy
print(numpy.__version__)

import numpy as np
print(np.__version__)

#Create a numpy array from a Python list
l=[1,2,3,4,5,6,7,8,9]
a=np.array(l)#convert list ti n-dimensional array
print("Array from List",a)

#Creating 1Darray
a=np.array([10,20,30,40])
print("1D array",a)

#create a 2D array
a=np.array([[10,20,30], [40,50,60]])
print("2D array",a)

#create evenly spaced integers with range
a=np.arange(0,10,2)
print("Range Array",a)

#create evenly spaced floats using linspace
a=np.linspace(0,1,5)
print("Linspace Array",a)

#create a 2*3 array of all zeros
a=np.zeros((2,3))
print("Zeros Array",a)

#create a 3*2 array of all ones
a=np.ones((3,2))
print("Ones Array",a)

#create a 2*2 array filled with value 7
a=np.full((2,2),7)
print("Full Array \n",a)

#create a 2Darray with 2 rows and 3 columns
a=np.array([[10,20,30], [40,50,60]])
print("2D Array \n",a)

#Shape tuple of(rows,columns)
print("Shape of Array",a.shape)

#Number of Dimensions(axes). 1D,2D,3D
print("Dimension of Array",a.ndim)

#dtype:data type of the elements (int32,float64)
print("Data Type of Array",a.dtype)

#size:total number of elements in the array
print("Size of Array",a.size)

#each row=a product ; each column=a month(Jan to Mar)
s=np.array([
    [100,200,300],#Product A
     [400,500,600],#Product B
      [500,600,700]#Product C
    ])
print("Sales Data \n",s)

#Elemnt at row 0,column 1(Product A in Feb)
print("Sales of Product A in Feb",s[0,1])

#entire first row(Product A)
print("Sales of Product A",s[0])

#last column (March for all Products)
print("Sales of March",s[:,-1])

#Subarray: First 2 rows and 2 columns
print("Subarray \n",s[:2,:2])

#reverse the order of rows(Products C,B,A)
print("Reverse Rows \n",s[::-1])

#Every other column(Jan and Mar)
print("Every Other Column \n",s[:,::2])

print(s[-1:-3:-1])

print(s[-1:-3])

print(s[-3:-3:-1])

print(s[-2:-3:-2])

print(s[-1:-3:-3])

#create a 3*4 array with values 1-12
t=np.arange(1,13).reshape(3,4)
print(t)

print(t[:,0])

#retrieve last 2 columns
print(t[:,-2:])

#reverse the array
print("Reverse Rows \n",t[::-1])

#define two arrays with same shape
a1=np.array([10,20,30,40])
a2=np.array([1,2,3,4])

#print basic arithmetic operations
print("Addition:",a1+a2)
print("Subtraction:",a1-a2)
print("Multiplication:",a1*a2)
print("Division:",a1/a2)

#Array and Scalar operation
print("Add 100 to a1:",a1+100)

#create a 2d array
m=np.array([[10,20,30],[40,50,60]])
print("Total Sum",np.sum(m))
print("Mean Value",np.mean(m))
print("Standard Deviation",np.std(m))
print("Sum by Column(axis=0)",np.sum(m,axis=0))#applies through column
print("Sum by Row(axis=1)",np.sum(m,axis=1))#applies through row
print("Mean by row",np.mean(m,axis=1))

#Masking and Filtering
s=np.array([60,75,80,85,90,45])
#Create a boolean marks for scores>=70
p=s>=70
print("Pass Mark:",p)
#filter values using marks
print("Passing Marks",s[p])
#combine conditions :select scores between 70 and 90
print("Between 70 and 90",s[(s>=70)&(s<=90)])

#use np.where to assign labels
l=np.where(s>=70,"Pass","Fail")
print("Labels:",l)

#create an array with nan values
d=np.array([6.0,np.nan,7.0,np.nan,5.0])
#detect nan positions
print("Nan Mask:",np.isnan(d))
#aggregate safely while ignoring nans
print("Mean ignoring nans",np.nanmean(d))
#Replace nans with 0
f=np.nan_to_num(d,nan=0.0)
print("Replaced nans with 0",f)

#create a 1D array of 12 elemnts
a=np.arange(12)
print("Original array:",a)
r=a.reshape(3,4)
print("Reshaped array",r)
ra=r.ravel()
f=r.flatten()
print("Raveled (1Dview):",ra)
print("Flattened (1D copy):",f)

print("Transpose array: \n",r.T)
#convert one row into a column
m=r[0]
m_c=m.reshape(-1,1)
print("Column Vector: \n",m_c)
#convert back to row
m_r=m_c.reshape(1,-1)
print("Row Vector: \n",m_r)

#combining arrays
a=np.array([[1,2],[3,4]])
b=np.array([[5,6],[7,8]])
#horizontal stack among columns
h=np.hstack((a,b))
print("Horizontal Stack: \n",h)
#vertical stack among rows
v=np.vstack((a,b))
print("Vertical Stack: \n",v)
#generic concatenate: axis=0 (rows), axis=1(columns)
c=np.concatenate((a,b),axis=0)
print("Concatenate Rows: \n",c)
c=np.concatenate((a,b),axis=1)
print("Concatenate Columns: \n",c)

#create a 2Darray
a=np.arange(16).reshape(4,4)
print("Original array: \n",a)
#split vertically into two 2*4 arrays
sv=np.vsplit(a,2)
print("Vertical Split(2*4 each)")
for s in sv:
  print(s)
#split horizontally into two 2*4 arrays
sr=np.hsplit(a,2)
print("Horizontal Split(2*4 each)")
for s in sr:
  print(s)

#advanced indexing
a=np.array([[10,20,30],[40,50,60],[70,80,90],[100,110,120]])
#select rows 0,2 and 3
s=a[:,[2,0,1]]
print("Selected Rows 0,2,3:\n",s)
#reorder columns
r=a[:,[2,0,1]]
print("Reordered Columns:\n",r)

d=np.array([45,512,89,33])
print("Original Array:",d)
#sorted values
print("Sorted Values:",np.sort(d))
print("Sorted Indices:",np.argsort(d))
print("Data sorted using indices:",d[np.argsort(d)])

#derived insights and data processing workflows
#simulated sales data (rows=products colums=months)
import numpy as np
s=np.array([
    [200,220,250,300],#product a
     [150,160,170,190],#product b
      [300,330,360,390]#product c
    ])
#Row wise sum
rs=np.sum(s,axis=1)
print("Total Sales per Product: \n",rs)
#Column mean
cm=np.mean(s,axis=0)
print("Average Monthly Sales: \n",cm)
#percent change across months
#(current-previous)/previous
pc=(s[:,1:]-s[:,:-1])/s[:,:-1]
print("Percentage change \n",pc)
print("Full mat \n",s)
print("Part mat \n",s[:,1:])
print("Part mat2 \n",s[:,:-1])

#set seed for reproductibility
np.random.seed(3)
#Random Integers
r_ints=np.random.randint(1,100,size=(3,4))
print("Random Integers: \n",r_ints)
#Normally distributed values(mean=0,std=1)
ns=np.random.normal(loc=0,scale=1,size=5)
print("Normal Samples:",ns)
#random choices from list
o=['a','b','c']
c=np.random.choice(o,size=5,replace=True)
print("Random Choices:",c)

